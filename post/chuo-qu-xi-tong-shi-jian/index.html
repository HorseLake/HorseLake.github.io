<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>C++获取系统时间 | Gridea</title>
<link rel="shortcut icon" href="https://LakeWorld.github.io/favicon.ico?v=1586998256814">
<link href="https://cdn.remixicon.com/releases/v2.1.0/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://LakeWorld.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="C++获取系统时间 | Gridea - Atom Feed" href="https://LakeWorld.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="方案：localtime()
优点：仅使用C标准库；缺点：只能精确到秒级
time_t是定义在time.h中的一个类型，表示一个日历时间，也就是从1970年1月1日0时0分0秒到此时的秒数，原型是：
 typedef long time_t..." />
    <meta name="keywords" content="C++ Code" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://LakeWorld.github.io">
  <img class="avatar" src="https://LakeWorld.github.io/images/avatar.png?v=1586998256814" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              C++获取系统时间
            </h2>
            <div class="post-info">
              <span>
                2020-04-16
              </span>
              <span>
                5 min read
              </span>
              
                <a href="https://LakeWorld.github.io/tag/mazlWncxg/" class="post-tag">
                  # C++ Code
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h2 id="方案localtime">方案：localtime()</h2>
<h6 id="优点仅使用c标准库缺点只能精确到秒级">优点：仅使用C标准库；缺点：只能精确到秒级</h6>
<p>time_t是定义在time.h中的一个类型，表示一个日历时间，也就是从1970年1月1日0时0分0秒到此时的秒数，原型是：</p>
<pre><code class="language-cpp"> typedef long time_t;        /* time value */
</code></pre>
<p>可以看出time_t其实是一个长整型，由于长整型能表示的数值有限，因此它能表示的最迟时间是2038年1月18日19时14分07秒。</p>
<p>函数time可以获取当前日历时间时间，time的定义：<br>
time_t time(time_t *)</p>
<p>time_t (typedef __int64  time_t )只是一个长整型，不符合我们的使用习惯，需要转换成本地时间，就要用到tm结构，time.h中结构tm的原型是：</p>
<pre><code class="language-cpp">struct tm {  
        int tm_sec;     /* seconds after the minute - [0,59] */  
        int tm_min;     /* minutes after the hour - [0,59] */  
        int tm_hour;    /* hours since midnight - [0,23] */  
        int tm_mday;    /* day of the month - [1,31] */  
        int tm_mon;     /* months since January - [0,11] */  
        int tm_year;    /* years since 1900 */  
        int tm_wday;    /* days since Sunday - [0,6] */  
        int tm_yday;    /* days since January 1 - [0,365] */  
        int tm_isdst;   /* daylight savings time flag */  
       };  
</code></pre>
<p>可以看出，这个机构定义了年、月、日、时、分、秒、星期、当年中的某一天、夏令时。可以用这个结构很方便的显示时间。</p>
<p>用localtime获取当前系统时间，该函数将一个time_t时间转换成tm结构表示的时间，函数原型：<br>
struct tm * localtime(const time_t *)<br>
使用gmtime函数获取格林尼治时间，函数原型：<br>
struct tm * gmtime(const time_t *)</p>
<h3 id="输出方式1">输出方式1：</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;  
#include &lt;time.h&gt;  
using namespace std;  
void dsptime(const struct tm *); //输出时间。  
  
int main(void)  
{  
 time_t nowtime;  
 nowtime = time(NULL); //获取日历时间  
 cout &lt;&lt; nowtime &lt;&lt; endl;  //输出nowtime  
  
 struct tm *local,*gm;  
 local=localtime(&amp;nowtime);  //获取当前系统时间  
 dsptime(local);   
 gm=gmtime(&amp;nowtime);  //获取格林尼治时间  
 dsptime(gm);  
    
 return 0;  
}  
void dsptime(const struct tm * ptm)  
{  
 char *pxq[]={&quot;日&quot;,&quot;一&quot;,&quot;二&quot;,&quot;三&quot;,&quot;四&quot;,&quot;五&quot;,&quot;六&quot;};  
 cout &lt;&lt; ptm-&gt;tm_year+1900 &lt;&lt; &quot;年&quot; &lt;&lt; ptm-&gt;tm_mon+1 &lt;&lt; &quot;月&quot; &lt;&lt; ptm-&gt;tm_mday &lt;&lt; &quot;日 &quot; ;  
 cout &lt;&lt; ptm-&gt;tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; ptm-&gt;tm_min &lt;&lt; &quot;:&quot; &lt;&lt; ptm-&gt;tm_sec &lt;&lt;&quot; &quot; ;  
 cout &lt;&lt; &quot; 星期&quot; &lt;&lt;pxq[ptm-&gt;tm_wday] &lt;&lt; &quot; 当年的第&quot; &lt;&lt; ptm-&gt;tm_yday &lt;&lt; &quot;天 &quot; &lt;&lt; endl;  
}  
</code></pre>
<p>输出方式2：</p>
<pre><code class="language-cpp">#include &lt;time.h&gt;   
#include &lt;stdio.h&gt;   
int main( void )   
{   
    time_t t = time(0);   
    char tmp[64];   
    strftime( tmp, sizeof(tmp), &quot;%Y/%m/%d %X %A 本年第%j天 %z&quot;,localtime(&amp;t) );   
    puts( tmp );   
    return 0;   
}  
</code></pre>
<p>C/C++在time.h中提供了一个自定义时间格式的函数strftime，函数原型：<br>
size_t strftime(char *strDest, size_t maxsize, const char *format, const struct tm *timeptr);<br>
可使用的格式化字符串：</p>
<pre><code>%a 星期几的简写 
%A 星期几的全称 
%b 月分的简写 
%B 月份的全称 
%c 标准的日期的时间串 
%C 年份的后两位数字 
%d 十进制表示的每月的第几天 
%D 月/天/年 
%e 在两字符域中，十进制表示的每月的第几天 
%F 年-月-日 
%g 年份的后两位数字，使用基于周的年 
%G 年分，使用基于周的年 
%h 简写的月份名 
%H 24小时制的小时 
%I 12小时制的小时
%j 十进制表示的每年的第几天 
%m 十进制表示的月份 
%M 十时制表示的分钟数 
%n 新行符 
%p 本地的AM或PM的等价显示 
%r 12小时的时间 
%R 显示小时和分钟：hh:mm 
%S 十进制的秒数 
%t 水平制表符 
%T 显示时分秒：hh:mm:ss 
%u 每周的第几天，星期一为第一天 （值从0到6，星期一为0）
%U 第年的第几周，把星期日做为第一天（值从0到53）
%V 每年的第几周，使用基于周的年 
%w 十进制表示的星期几（值从0到6，星期天为0）
%W 每年的第几周，把星期一做为第一天（值从0到53） 
%x 标准的日期串 
%X 标准的时间串 
%y 不带世纪的十进制年份（值从0到99）
%Y 带世纪部分的十进制年份 
%z，%Z 时区名称，如果不能得到时区名称则返回空字符。
%% 百分号
···</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E6%96%B9%E6%A1%88localtime">方案：localtime()</a><br>
*<br>
*<br>
*<br>
* <a href="#%E4%BC%98%E7%82%B9%E4%BB%85%E4%BD%BF%E7%94%A8c%E6%A0%87%E5%87%86%E5%BA%93%E7%BC%BA%E7%82%B9%E5%8F%AA%E8%83%BD%E7%B2%BE%E7%A1%AE%E5%88%B0%E7%A7%92%E7%BA%A7">优点：仅使用C标准库；缺点：只能精确到秒级</a>
<ul>
<li><a href="#%E8%BE%93%E5%87%BA%E6%96%B9%E5%BC%8F1">输出方式1：</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://LakeWorld.github.io/post/hello-gridea/">
              <h3 class="post-title">
                Hello Gridea
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://LakeWorld.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
